const { useState, useRef } = window.React;
const { Globe, Bell, Cpu, MessageSquare, Mail, Database, Clock, Split, Box, Bot, GitBranch, Settings, Play, ArrowLeft, Plus, X, Move } = window.LucideReact;

const WorkflowEditor = ({ onClose }) => {
            const [nodes, setNodes] = useState([ { id: 1, type: 'trigger', label: 'Webhook (Start)', x: 100, y: 150, iconName: 'Globe' }, { id: 2, type: 'action', label: 'Analyze Text (LLM)', x: 400, y: 150, iconName: 'Cpu' }, { id: 3, type: 'action', label: 'Send to Slack', x: 700, y: 150, iconName: 'MessageSquare' } ]);
            const [edges, setEdges] = useState([ { id: 'e1-2', source: 1, target: 2, label: '' }, { id: 'e2-3', source: 2, target: 3, label: 'JSON Data' } ]);
            const [draggingNodeId, setDraggingNodeId] = useState(null);
            const [dragOffset, setDragOffset] = useState({ x: 0, y: 0 });
            const [connectingSource, setConnectingSource] = useState(null); 
            const [mousePos, setMousePos] = useState({ x: 0, y: 0 });
            const [selectedNodeId, setSelectedNodeId] = useState(null); 
            const [selectedEdgeId, setSelectedEdgeId] = useState(null);
            const [panelPosition, setPanelPosition] = useState({ x: 300, y: 120 }); 
            const [isPanelDragging, setIsPanelDragging] = useState(false);
            const [panelDragOffset, setPanelDragOffset] = useState({ x: 0, y: 0 });
            const canvasRef = useRef(null);
            const [activeSidebarTab, setActiveSidebarTab] = useState('nodes');
            
            const IconMap = { Globe, Bell, Cpu, MessageSquare, Mail, Database, Clock, Split, Box, Bot, GitBranch };
            const toolCategories = { 'Trigger': [ { type: 'trigger', label: 'Webhook', iconName: 'Globe' }, { type: 'trigger', label: 'Schedule', iconName: 'Clock' } ], 'Action': [ { type: 'action', label: 'LLM Analysis', iconName: 'Cpu' }, { type: 'action', label: 'Slack Message', iconName: 'MessageSquare' }, { type: 'action', label: 'Send Email', iconName: 'Mail' }, { type: 'action', label: 'DB Insert', iconName: 'Database' } ], 'Logic': [ { type: 'logic', label: 'If/Else', iconName: 'Split' }, { type: 'helper', label: 'Formatter', iconName: 'Box' } ] };
            const libraryItems = { '내 커넥터': [ { id: 'c1', label: 'Nexon User API', type: 'connector', iconName: 'Database' }, { id: 'c2', label: 'Slack Notifier', type: 'connector', iconName: 'MessageSquare' } ], '내 에이전트': [ { id: 'a1', label: 'CS Responder', type: 'agent', iconName: 'Bot' }, { id: 'a2', label: 'Data Analyst', type: 'agent', iconName: 'Bot' } ], '내 워크플로우': [ { id: 'w1', label: 'Email Summary', type: 'workflow', iconName: 'GitBranch' } ] };

            const handleNodeLabelChange = (newLabel) => setNodes(nds => nds.map(n => n.id === selectedNodeId ? { ...n, label: newLabel } : n));
            const handleEdgeLabelChange = (newLabel) => setEdges(eds => eds.map(e => e.id === selectedEdgeId ? { ...e, label: newLabel } : e));
            const handleEdgeDelete = () => { setEdges(eds => eds.filter(e => e.id !== selectedEdgeId)); setSelectedEdgeId(null); };
            const handlePanelMouseDown = (e) => { e.stopPropagation(); setIsPanelDragging(true); setPanelDragOffset({ x: e.clientX - panelPosition.x, y: e.clientY - panelPosition.y }); };
            const handleNodeMouseDown = (e, nodeId) => { e.stopPropagation(); const node = nodes.find(n => n.id === nodeId); const rect = e.currentTarget.getBoundingClientRect(); setDragOffset({ x: e.clientX - rect.left, y: e.clientY - rect.top }); setDraggingNodeId(nodeId); };
            const handleNodeSettingsClick = (e, nodeId) => { e.stopPropagation(); setSelectedNodeId(nodeId); setSelectedEdgeId(null); };
            const handleEdgeClick = (e, edgeId) => { e.stopPropagation(); setSelectedEdgeId(edgeId); setSelectedNodeId(null); };
            const handleCanvasClick = () => { setSelectedNodeId(null); setSelectedEdgeId(null); };
            const handleNodeDelete = (e, nodeId) => { e.stopPropagation(); if (selectedNodeId === nodeId) setSelectedNodeId(null); setNodes(nds => nds.filter(n => n.id !== nodeId)); setEdges(eds => eds.filter(edge => edge.source !== nodeId && edge.target !== nodeId)); };
            const handlePortMouseDown = (e, nodeId, portType) => { e.stopPropagation(); e.preventDefault(); if (portType === 'source') { const rect = e.currentTarget.getBoundingClientRect(); const canvasRect = canvasRef.current.getBoundingClientRect(); setConnectingSource({ nodeId, x: rect.left + rect.width / 2 - canvasRect.left, y: rect.top + rect.height / 2 - canvasRect.top }); } };
            const handlePortMouseUp = (e, nodeId, portType) => { e.stopPropagation(); if (connectingSource && portType === 'target') { if (connectingSource.nodeId !== nodeId) { const newEdge = { id: `e${connectingSource.nodeId}-${nodeId}-${Date.now()}`, source: connectingSource.nodeId, target: nodeId, label: '' }; if (!edges.some(edge => edge.source === newEdge.source && edge.target === newEdge.target)) setEdges(eds => [...eds, newEdge]); } } setConnectingSource(null); };
            const handleMouseMove = (e) => { if (isPanelDragging) { setPanelPosition({ x: e.clientX - panelDragOffset.x, y: e.clientY - panelDragOffset.y }); return; } if (!canvasRef.current) return; const canvasRect = canvasRef.current.getBoundingClientRect(); const x = e.clientX - canvasRect.left; const y = e.clientY - canvasRect.top; setMousePos({ x, y }); if (draggingNodeId) { const nodeX = x - dragOffset.x; const nodeY = y - dragOffset.y; setNodes(nds => nds.map(n => n.id === draggingNodeId ? { ...n, x: nodeX, y: nodeY } : n)); } };
            const handleMouseUp = () => { setDraggingNodeId(null); setIsPanelDragging(false); setConnectingSource(null); };
            const handleSidebarDragStart = (e, type, label, iconName) => { e.dataTransfer.setData('application/reactflow', JSON.stringify({ type, label, iconName })); e.dataTransfer.effectAllowed = 'move'; };
            const handleDrop = (e) => { e.preventDefault(); const typeData = e.dataTransfer.getData('application/reactflow'); if (typeData && canvasRef.current) { const { type, label, iconName } = JSON.parse(typeData); const rect = canvasRef.current.getBoundingClientRect(); const x = e.clientX - rect.left - 88; const y = e.clientY - rect.top - 40; const newNode = { id: Date.now(), type, label, x, y, iconName }; setNodes(nds => [...nds, newNode]); setSelectedNodeId(newNode.id); setSelectedEdgeId(null); } };
            const handleDragOver = (e) => { e.preventDefault(); e.dataTransfer.dropEffect = 'move'; };
            const NODE_WIDTH = 176;
            const NODE_HEIGHT = 88;
            const NODE_PADDING = 16;
            const isSegmentIntersectingRect = (segment, rect) => {
                const { x1, y1, x2, y2 } = segment;
                if (y1 === y2) {
                    const minX = Math.min(x1, x2);
                    const maxX = Math.max(x1, x2);
                    return y1 >= rect.top && y1 <= rect.bottom && maxX >= rect.left && minX <= rect.right;
                }
                if (x1 === x2) {
                    const minY = Math.min(y1, y2);
                    const maxY = Math.max(y1, y2);
                    return x1 >= rect.left && x1 <= rect.right && maxY >= rect.top && minY <= rect.bottom;
                }
                return false;
            };
            const getNodeRect = (node) => ({
                left: node.x - NODE_PADDING,
                right: node.x + NODE_WIDTH + NODE_PADDING,
                top: node.y - NODE_PADDING,
                bottom: node.y + NODE_HEIGHT + NODE_PADDING
            });
            const getPolylineSegments = (points) => points.slice(1).map((point, index) => ({ x1: points[index].x, y1: points[index].y, x2: point.x, y2: point.y }));
            const isPathClear = (points, obstacleNodes) => {
                const segments = getPolylineSegments(points);
                return !segments.some(segment => obstacleNodes.some(node => isSegmentIntersectingRect(segment, getNodeRect(node))));
            };
            const getSmartPath = (sx, sy, tx, ty, sourceId, targetId) => {
                const midX = (sx + tx) / 2;
                const obstacles = nodes.filter(node => node.id !== sourceId && node.id !== targetId);
                const basePath = `M ${sx} ${sy} C ${sx + 60} ${sy}, ${tx - 60} ${ty}, ${tx} ${ty}`;
                const basePoints = [ { x: sx, y: sy }, { x: midX, y: sy }, { x: midX, y: ty }, { x: tx, y: ty } ];
                if (isPathClear(basePoints, obstacles)) {
                    return basePath;
                }
                const offsets = [ -120, 120, -200, 200, -280, 280 ];
                for (const offset of offsets) {
                    const bendY = sy + offset;
                    const points = [
                        { x: sx, y: sy },
                        { x: midX, y: sy },
                        { x: midX, y: bendY },
                        { x: tx, y: bendY },
                        { x: tx, y: ty }
                    ];
                    if (isPathClear(points, obstacles)) {
                        return `M ${sx} ${sy} L ${midX} ${sy} L ${midX} ${bendY} L ${tx} ${bendY} L ${tx} ${ty}`;
                    }
                }
                return basePath;
            };
            const selectedNode = selectedNodeId ? nodes.find(n => n.id === selectedNodeId) : null;
            const selectedEdge = selectedEdgeId ? edges.find(e => e.id === selectedEdgeId) : null;
            const isPropertyPanelVisible = selectedNode || selectedEdge;

            return (
                <div className="fixed inset-0 z-50 flex flex-col h-screen w-screen bg-[#F4F6F9] animate-in" onMouseUp={handleMouseUp} onMouseLeave={handleMouseUp} onMouseMove={handleMouseMove}>
                    <div className="bg-white border-b border-slate-200 px-6 py-3 flex flex-col sm:flex-row justify-between items-start sm:items-center z-20 gap-3">
                        <div className="flex items-center gap-4">
                            <button onClick={onClose} className="p-2 hover:bg-slate-100 rounded-md text-slate-500 transition-colors"><ArrowLeft size={20} strokeWidth={2.5} /></button>
                            <div>
                                <div className="text-[11px] text-slate-400 font-medium">AI 워크플로우 / 편집</div>
                                <h3 className="font-semibold text-lg text-slate-900 flex items-center gap-2">새 워크플로우 1 <span className="text-[10px] font-semibold text-amber-600 border border-amber-200 px-2 py-0.5 rounded-md bg-amber-50">Draft</span></h3>
                            </div>
                        </div>
                        <div className="flex gap-2 w-full sm:w-auto">
                            <button className="flex-1 sm:flex-none justify-center px-4 py-2 bg-white hover:bg-slate-50 text-slate-600 rounded-md text-sm font-semibold border border-slate-200 flex items-center gap-2 shadow-sm"><Play size={16} strokeWidth={2.5} /> 실행 테스트</button>
                            <button className="flex-1 sm:flex-none justify-center px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded-md text-sm font-semibold shadow-sm">저장</button>
                        </div>
                    </div>
                    <div className="flex-1 flex flex-col md:flex-row relative overflow-hidden">
                        <div className="w-full md:w-80 bg-white border-b md:border-b-0 md:border-r border-slate-200 flex flex-col z-20 h-52 md:h-auto">
                            <div className="flex border-b border-slate-200 p-1 bg-slate-50 gap-1">
                                <button onClick={() => setActiveSidebarTab('nodes')} className={`flex-1 py-2 text-[11px] font-semibold uppercase tracking-wider rounded-md transition-all ${activeSidebarTab === 'nodes' ? 'bg-white text-blue-600 shadow-sm' : 'text-slate-400 hover:text-slate-600'}`}>기본 노드</button>
                                <button onClick={() => setActiveSidebarTab('library')} className={`flex-1 py-2 text-[11px] font-semibold uppercase tracking-wider rounded-md transition-all ${activeSidebarTab === 'library' ? 'bg-white text-blue-600 shadow-sm' : 'text-slate-400 hover:text-slate-600'}`}>스킬 불러오기</button>
                            </div>
                            <div className="px-4 pt-4">
                                <div className="flex items-center gap-2 bg-slate-100 rounded-md px-3 py-2 text-xs text-slate-500">
                                    <span className="w-2 h-2 rounded-full bg-blue-400"></span>
                                    <span>노드 검색 (Ctrl+K)</span>
                                </div>
                            </div>
                            <div className="p-4 space-y-6 overflow-y-auto flex-1 bg-white">
                                {activeSidebarTab === 'nodes' ? Object.entries(toolCategories).map(([cat, tools]) => (<div key={cat}><div className="text-[10px] font-semibold text-slate-400 mb-3 px-1 uppercase tracking-widest">{cat}</div><div className="space-y-2">{tools.map((tool, i) => { const ToolIcon = IconMap[tool.iconName] || Box; return (<div key={i} className="group px-3 py-2.5 bg-white hover:border-blue-300 border border-slate-200 rounded-lg cursor-grab active:cursor-grabbing flex items-center gap-3 transition-all shadow-sm hover:shadow-md" draggable onDragStart={(e) => handleSidebarDragStart(e, tool.type, tool.label, tool.iconName)}><div className={`p-1.5 rounded-md border ${tool.type === 'trigger' ? 'bg-orange-50 text-orange-600 border-orange-100' : tool.type === 'action' ? 'bg-blue-50 text-blue-600 border-blue-100' : 'bg-slate-100 text-slate-600 border-slate-200'}`}><ToolIcon size={16} strokeWidth={2.5} /></div><span className="text-sm font-semibold text-slate-700">{tool.label}</span><Plus size={16} className="ml-auto text-slate-300 opacity-0 group-hover:opacity-100" strokeWidth={2.5}/></div>) })}</div></div>)) : Object.entries(libraryItems).map(([category, items]) => (<div key={category}><div className="text-[10px] font-semibold text-slate-400 mb-3 px-1 uppercase tracking-widest">{category}</div><div className="space-y-2">{items.map((item, i) => { const ToolIcon = IconMap[item.iconName] || Box; return (<div key={item.id} className="group px-3 py-2.5 bg-white border border-slate-200 hover:border-indigo-300 hover:shadow-md rounded-lg cursor-grab active:cursor-grabbing flex items-center gap-3 transition-all" draggable onDragStart={(e) => handleSidebarDragStart(e, item.type, item.label, item.iconName)}><div className="p-1.5 rounded-md bg-indigo-50 text-indigo-600 border border-indigo-100"><ToolIcon size={16} strokeWidth={2.5} /></div><span className="text-sm font-semibold text-slate-700 truncate">{item.label}</span><Plus size={16} className="ml-auto text-slate-300 opacity-0 group-hover:opacity-100" strokeWidth={2.5}/></div>) })}</div></div>))}
                            </div>
                        </div>
                        <div className="flex-1 bg-[#F3F5F9] relative overflow-hidden cursor-default min-h-[400px] bg-grid-pattern" ref={canvasRef} onDrop={handleDrop} onDragOver={handleDragOver} onClick={handleCanvasClick}>
                            <svg className="absolute inset-0 w-full h-full z-0 overflow-visible">
                                {edges.map(edge => { const sourceNode = nodes.find(n => n.id === edge.source); const targetNode = nodes.find(n => n.id === edge.target); if (!sourceNode || !targetNode) return null; const sx = sourceNode.x + 176; const sy = sourceNode.y + 44; const tx = targetNode.x; const ty = targetNode.y + 44; const path = getSmartPath(sx, sy, tx, ty, sourceNode.id, targetNode.id); const isSelected = selectedEdgeId === edge.id; return (<g key={edge.id} onClick={(e) => handleEdgeClick(e, edge.id)} className="group cursor-pointer"><path d={path} stroke="transparent" strokeWidth="16" fill="none" /><path d={path} stroke={isSelected ? "#3b82f6" : "#d6dbe4"} strokeWidth={isSelected ? "4" : "3"} fill="none" className={`transition-colors ${!isSelected && 'group-hover:stroke-blue-400'}`} strokeLinecap="round" />{edge.label && (<g transform={`translate(${(sx + tx) / 2}, ${(sy + ty) / 2})`}><rect x="-50" y="-14" width="100" height="28" rx="8" fill="white" stroke={isSelected ? "#3b82f6" : "#d6dbe4"} strokeWidth="1.5" className="shadow-sm"/><text x="0" y="5" textAnchor="middle" className={`text-[11px] font-semibold ${isSelected ? 'fill-blue-600' : 'fill-slate-500'}`}>{edge.label}</text></g>)}</g>); })}
                                {connectingSource && (<path d={`M ${connectingSource.x} ${connectingSource.y} C ${connectingSource.x + 60} ${connectingSource.y}, ${mousePos.x - 60} ${mousePos.y}, ${mousePos.x} ${mousePos.y}`} stroke="#3b82f6" strokeWidth="3" fill="none" strokeDasharray="6,6" className="pointer-events-none" strokeLinecap="round" />)}
                            </svg>
                            {nodes.map(node => { const NodeIcon = IconMap[node.iconName] || Box; const isDragging = draggingNodeId === node.id; const isSelected = selectedNodeId === node.id; const isLibraryItem = ['connector', 'agent', 'workflow'].includes(node.type); const accentColor = node.type === 'trigger' ? 'border-orange-500' : node.type === 'action' ? 'border-blue-500' : isLibraryItem ? 'border-indigo-500' : 'border-slate-500'; return (<div key={node.id} onMouseDown={(e) => handleNodeMouseDown(e, node.id)} className={`absolute w-44 h-[88px] bg-white border-l-4 ${accentColor} border border-slate-200 rounded-lg shadow-sm p-0 flex flex-col group transition-all cursor-grab active:cursor-grabbing z-10 ${isDragging || isSelected ? 'shadow-lg border-blue-400 z-50 ring-2 ring-blue-500/20' : 'hover:border-blue-300'}`} style={{ left: node.x, top: node.y }}><div className="p-3 flex items-center gap-3 border-b border-slate-100 rounded-t-lg select-none relative bg-white"><div className={`w-8 h-8 rounded-md flex items-center justify-center text-white shadow-sm ${node.type === 'trigger' ? 'bg-orange-500' : isLibraryItem ? 'bg-indigo-600' : node.type === 'action' ? 'bg-blue-600' : 'bg-slate-500'}`}><NodeIcon size={16} strokeWidth={2.5} /></div><div className="text-xs font-semibold text-slate-700 truncate flex-1">{node.label}</div><button onClick={(e) => handleNodeSettingsClick(e, node.id)} className="bg-slate-50 rounded-md p-1.5 border border-slate-200 text-slate-400 hover:text-blue-500 hover:border-blue-200 transition-colors"><Settings size={14} /></button><button onClick={(e) => handleNodeDelete(e, node.id)} className="absolute -top-2.5 -right-2.5 bg-white rounded-full p-1 shadow-md border border-slate-200 text-slate-400 hover:text-white hover:bg-red-500 hover:border-red-500 opacity-0 group-hover:opacity-100 transition-all z-20 scale-75 hover:scale-100"><X size={12} strokeWidth={2.5} /></button></div><div className="p-2 bg-slate-50 rounded-b-lg select-none"><div className="text-[10px] text-slate-400 flex justify-between px-2 font-semibold uppercase tracking-wide"><span>Input</span><span>Output</span></div></div><div onMouseUp={(e) => handlePortMouseUp(e, node.id, 'target')} className="absolute -left-2 top-1/2 -translate-y-1/2 w-3 h-3 bg-white border-[2.5px] border-slate-300 rounded-full hover:border-blue-500 transition-transform hover:scale-125 cursor-crosshair z-20 shadow-sm" title="Input"></div><div onMouseDown={(e) => handlePortMouseDown(e, node.id, 'source')} className="absolute -right-2 top-1/2 -translate-y-1/2 w-3 h-3 bg-white border-[2.5px] border-slate-300 rounded-full hover:border-blue-500 transition-transform hover:scale-125 cursor-crosshair z-20 shadow-sm" title="Output"></div></div>); })}
                        </div>
                        {isPropertyPanelVisible && (
                            <div className="absolute w-80 bg-white rounded-2xl shadow-xl border border-slate-200 overflow-hidden z-50 flex flex-col animate-in" style={{ left: panelPosition.x, top: panelPosition.y, cursor: isPanelDragging ? 'grabbing' : 'default' }}>
                                <div onMouseDown={handlePanelMouseDown} className="bg-slate-50 border-b border-slate-200 px-4 py-3 flex items-center justify-between cursor-grab active:cursor-grabbing"><h4 className="font-semibold text-slate-700 text-sm flex items-center gap-2"><Settings size={16}/> {selectedNode ? '노드 속성' : '연결선 속성'}</h4><div className="flex items-center gap-2"><Move size={16} className="text-slate-400"/><button onClick={() => { setSelectedNodeId(null); setSelectedEdgeId(null); }} className="text-slate-400 hover:text-red-500"><X size={16} strokeWidth={2.5}/></button></div></div>
                                <div className="p-5 space-y-4 bg-white">
                                    {selectedNode ? (
                                        <>
                                            <div className="space-y-1">
                                                <label className="text-[11px] font-semibold text-slate-400 uppercase tracking-wide">Node Name</label>
                                                <input type="text" value={selectedNode.label} onChange={(e) => handleNodeLabelChange(e.target.value)} className="w-full bg-slate-50 border border-slate-200 rounded-lg px-3 py-2 text-sm text-slate-800 focus:outline-none focus:border-blue-500 transition-all font-semibold"/>
                                            </div>
                                            <div className="space-y-1">
                                                <label className="text-[11px] font-semibold text-slate-400 uppercase tracking-wide">Type</label>
                                                <div className="px-3 py-2 bg-slate-100 rounded-lg text-xs text-slate-600 border border-slate-200 font-mono font-semibold">{selectedNode.type}</div>
                                            </div>
                                            <div className="space-y-1">
                                                <div className="text-[11px] font-semibold text-slate-400 uppercase tracking-wide mb-1">Configuration</div>
                                                <div className="h-24 bg-slate-50 border border-slate-200 rounded-lg p-3 text-xs text-slate-400 font-medium">{selectedNode.type === 'trigger' ? 'Webhook URL settings...' : selectedNode.type === 'action' ? 'API Endpoint configuration...' : 'Logic parameters...'}</div>
                                            </div>
                                        </>
                                    ) : (
                                        <>
                                            <div className="space-y-1">
                                                <label className="text-[11px] font-semibold text-slate-400 uppercase tracking-wide">Edge ID</label>
                                                <div className="px-3 py-2 bg-slate-100 rounded-lg text-xs text-slate-400 border border-slate-200 font-mono truncate font-semibold">{selectedEdge.id}</div>
                                            </div>
                                            <div className="space-y-1">
                                                <label className="text-[11px] font-semibold text-slate-400 uppercase tracking-wide">Label (Optional)</label>
                                                <input type="text" value={selectedEdge.label || ''} onChange={(e) => handleEdgeLabelChange(e.target.value)} placeholder="연결선 이름 입력..." className="w-full bg-slate-50 border border-slate-200 rounded-lg px-3 py-2 text-sm text-slate-800 focus:outline-none focus:border-blue-500 transition-all font-semibold"/>
                                            </div>
                                            <div className="pt-3 border-t border-slate-100 mt-2">
                                                <button onClick={handleEdgeDelete} className="w-full flex items-center justify-center gap-2 px-4 py-2.5 bg-red-50 hover:bg-red-100 text-red-600 rounded-lg text-xs font-semibold transition-colors border border-red-100 shadow-sm"><X size={14} strokeWidth={2.5}/> 연결 삭제</button>
                                            </div>
                                        </>
                                    )}
                                </div>
                            </div>
                        )}
                    </div>
                </div>
            );
        };

window.AppComponents.WorkflowEditor = WorkflowEditor;
